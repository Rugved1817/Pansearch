<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Transaction Search</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
	<style>
		:root {
			--bg: #0a0d12;
			--bg-2: #0b1118;
			--panel: #0e141d;
			--muted: #9fb2c6;
			--text: #eaf1f8;
			--primary: #60d5ff;
			--accent: #9b8cff;
			--accent-hover: #b5a8ff;
			--danger: #ff6b6b;
			--success: #51cf66;
			--border: #1a2431;
			--border-light: #253141;
			--row-alt: #0c131b;
			--focus-ring: rgba(155,140,255,0.35);
			--shadow-1: 0 10px 30px rgba(0,0,0,.35);
			--shadow-2: 0 1px 0 rgba(255,255,255,0.03) inset;
			--shadow-glow: 0 0 20px rgba(155,140,255,0.15);
			--gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			--gradient-accent: linear-gradient(135deg, #9b8cff 0%, #60d5ff 100%);
		}
		* { box-sizing: border-box; margin: 0; padding: 0; }
		html, body { height: 100%; }
		::selection { background: rgba(155,140,255,0.35); color: #fff; }
		body { 
			margin: 0; 
			background:
				radial-gradient(1200px 700px at 8% -8%, rgba(96,213,255,0.08), transparent 65%),
				radial-gradient(900px 600px at 100% 0%, rgba(155,140,255,0.09), transparent 60%),
				radial-gradient(800px 500px at 50% 100%, rgba(118,75,162,0.05), transparent 50%),
				linear-gradient(180deg, var(--bg), var(--bg-2));
			color: var(--text); 
			font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; 
			-webkit-font-smoothing: antialiased; 
			-moz-osx-font-smoothing: grayscale;
			overflow-x: hidden;
		}
		.container { max-width: 1400px; margin: 0 auto; padding: 32px 24px; }
		h1 { 
			font-size: 32px; 
			margin: 0 0 8px; 
			letter-spacing: -0.5px; 
			color: #ffffff; 
			font-weight: 700;
			background: var(--gradient-accent);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			background-clip: text;
		}
		.header { 
			display: flex; 
			align-items: center; 
			justify-content: space-between; 
			gap: 16px; 
			margin-bottom: 32px;
			padding-bottom: 24px;
			border-bottom: 1px solid var(--border);
		}
		.cart-button { 
			display: inline-flex;
			align-items: center;
			gap: 10px;
			background: linear-gradient(135deg, rgba(155,140,255,0.18), rgba(96,213,255,0.15));
			padding: 10px 18px;
			border-radius: 999px;
			border: 1px solid rgba(155,140,255,0.35);
			color: #d7deff;
			font-size: 14px;
			font-weight: 600;
			text-decoration: none;
			box-shadow: 0 6px 16px rgba(155,140,255,0.18);
			transition: all 0.25s ease;
			backdrop-filter: saturate(140%) blur(12px);
		}
		.cart-button:hover {
			transform: translateY(-1px);
			box-shadow: 0 10px 24px rgba(155,140,255,0.28);
			border-color: rgba(155,140,255,0.55);
		}
		.cart-button:active {
			transform: translateY(0px);
		}
		.cart-button .cart-dot {
			font-size: 16px;
			opacity: 0.6;
		}
		.cart-button .cart-count {
			font-weight: 700;
			color: #ffffff;
		}

		mark { 
			background: linear-gradient(135deg, rgba(255, 235, 59, 0.3), rgba(255, 235, 59, 0.2)); 
			color: #fff; 
			padding: 0 .2em; 
			border-radius: 4px; 
			box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.3) inset;
			font-weight: 500;
		}

		.card { 
			background: linear-gradient(180deg, rgba(14,21,33,0.8), rgba(12,18,26,0.9)); 
			border: 1px solid var(--border-light); 
			border-radius: 20px; 
			padding: 28px; 
			box-shadow: 
				0 20px 40px rgba(0,0,0,.4),
				0 0 0 1px rgba(255,255,255,0.02) inset,
				0 1px 0 rgba(255,255,255,0.05) inset;
			backdrop-filter: saturate(120%) blur(10px);
			transition: all 0.3s ease;
		}
		.card:hover {
			border-color: var(--border-light);
			box-shadow: 
				0 24px 48px rgba(0,0,0,.45),
				0 0 0 1px rgba(155,140,255,0.1) inset,
				0 1px 0 rgba(255,255,255,0.05) inset;
		}
		.row { display: grid; grid-template-columns: repeat(12, 1fr); gap: 16px; }
		.col-2 { grid-column: span 2; }
		.col-3 { grid-column: span 3; }
		.col-4 { grid-column: span 4; }
		.col-6 { grid-column: span 6; }
		.col-8 { grid-column: span 8; }

		.input { 
			width: 100%; 
			background: rgba(11,17,24,0.6); 
			border: 1px solid var(--border); 
			color: var(--text); 
			padding: 14px 16px; 
			border-radius: 14px; 
			outline: none; 
			transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1); 
			font-size: 14px; 
			font-weight: 500;
			box-shadow: var(--shadow-2);
		}
		.input::placeholder { color: #6f8194; font-weight: 400; }
		.input:hover { 
			background: rgba(12,19,27,0.7); 
			border-color: var(--border-light);
			transform: translateY(-1px);
		}
		.input:focus { 
			border-color: var(--accent); 
			box-shadow: 
				0 0 0 4px var(--focus-ring), 
				0 0 0 1px rgba(255,255,255,0.05) inset,
				0 4px 12px rgba(155,140,255,0.2);
			background: rgba(12,19,27,0.8);
			transform: translateY(-1px);
		}
		.label { 
			display: block; 
			font-size: 13px; 
			color: var(--muted); 
			margin-bottom: 8px; 
			font-weight: 600;
			letter-spacing: 0.3px;
		}
		.btn { 
			background: linear-gradient(135deg, rgba(37,50,70,0.8), rgba(27,37,51,0.9)); 
			color: #e8f3ff; 
			border: 1px solid var(--border); 
			padding: 12px 20px; 
			border-radius: 14px; 
			cursor: pointer; 
			font-weight: 600; 
			font-size: 14px;
			letter-spacing: .3px; 
			transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); 
			box-shadow: var(--shadow-2);
			position: relative;
			overflow: hidden;
		}
		.btn::before {
			content: '';
			position: absolute;
			top: 0;
			left: -100%;
			width: 100%;
			height: 100%;
			background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
			transition: left 0.5s;
		}
		.btn:hover::before {
			left: 100%;
		}
		.btn:hover { 
			filter: brightness(1.15); 
			box-shadow: 
				0 8px 20px rgba(0,0,0,.4), 
				var(--shadow-2),
				0 0 0 1px rgba(155,140,255,0.2);
			transform: translateY(-2px);
			border-color: var(--border-light);
		}
		.btn:active { transform: translateY(0px); }
		.btn:focus-visible { 
			outline: none; 
			box-shadow: 
				0 0 0 4px var(--focus-ring), 
				var(--shadow-2),
				0 4px 12px rgba(155,140,255,0.3);
		}
		.btn-primary { 
			background: var(--gradient-accent);
			border-color: rgba(155,140,255,0.3);
			box-shadow: 
				0 4px 16px rgba(155,140,255,0.25),
				var(--shadow-2);
		}
		.btn-primary:hover {
			box-shadow: 
				0 8px 24px rgba(155,140,255,0.35),
				var(--shadow-2),
				0 0 0 1px rgba(155,140,255,0.3);
		}
		.btn-ghost { 
			background: transparent; 
			border-color: var(--border);
		}
		.btn-ghost:hover {
			background: rgba(37,50,70,0.3);
		}
		.btn[disabled] { 
			opacity: 0.5; 
			cursor: not-allowed; 
			filter: none;
			transform: none !important;
		}
		.btn .spinner { 
			display: none; 
			width: 14px; 
			height: 14px; 
			border: 2px solid #cfe3ff; 
			border-top-color: transparent; 
			border-radius: 50%; 
			margin-left: 8px; 
			animation: spin .8s linear infinite; 
		}
		.btn.loading .spinner { display: inline-block; }
		.btn.loading .btn-label { opacity: .85; }
		@keyframes spin { to { transform: rotate(360deg); } }

		.toolbar { 
			display: flex; 
			align-items: center; 
			gap: 12px; 
			margin-top: 16px; 
			flex-wrap: wrap; 
		}
		.stat { 
			color: var(--muted); 
			font-size: 12px; 
			padding: 8px 14px; 
			background: rgba(12,19,27,0.6); 
			border: 1px solid var(--border); 
			border-radius: 12px; 
			box-shadow: var(--shadow-2);
			font-weight: 500;
		}
		
		.tag { 
			display: inline-flex; 
			align-items: center; 
			gap: 8px; 
			padding: 8px 14px; 
			background: linear-gradient(135deg, rgba(37,50,70,0.6), rgba(27,37,51,0.7)); 
			color: #e8f3ff; 
			border: 1px solid var(--border); 
			border-radius: 12px; 
			font-size: 13px; 
			font-weight: 500; 
			cursor: pointer; 
			transition: all .2s ease; 
			box-shadow: var(--shadow-2);
		}
		.tag:hover { 
			filter: brightness(1.15); 
			box-shadow: 
				0 6px 16px rgba(0,0,0,.35), 
				var(--shadow-2),
				0 0 0 1px rgba(155,140,255,0.2);
			transform: translateY(-2px);
		}
		.tag-text { user-select: none; }
		.tag-close { 
			display: inline-flex; 
			align-items: center; 
			justify-content: center; 
			width: 18px; 
			height: 18px; 
			border-radius: 50%; 
			background: rgba(255,255,255,0.15); 
			color: #e8f3ff; 
			font-size: 14px; 
			line-height: 1; 
			cursor: pointer; 
			transition: all .2s ease; 
			margin-left: 4px; 
		}
		.tag-close:hover { 
			background: rgba(255,107,107,0.4); 
			color: #ff6b6b; 
			transform: scale(1.15) rotate(90deg); 
		}
		.tag-close:active { transform: scale(0.95); }

		.table-wrap { 
			margin-top: 24px; 
			background: rgba(12,18,25,0.8); 
			border: 1px solid var(--border-light); 
			border-radius: 18px; 
			overflow: hidden; 
			overflow-x: auto; 
			box-shadow: 
				0 20px 40px rgba(0,0,0,.4),
				0 0 0 1px rgba(255,255,255,0.02) inset;
		}
		table { width: 100%; border-collapse: collapse; table-layout: auto; }
		thead th { 
			position: sticky; 
			top: 0; 
			background: linear-gradient(180deg, rgba(16,24,36,0.95), rgba(12,18,27,0.95)); 
			color: #d1deed; 
			font-weight: 700; 
			font-size: 12px; 
			text-align: left; 
			padding: 16px 14px; 
			border-bottom: 2px solid var(--border-light); 
			white-space: nowrap; 
			backdrop-filter: blur(12px);
			text-transform: uppercase;
			letter-spacing: 0.5px;
		}
		.select-header { 
			width: 56px; 
			text-align: center; 
			padding: 16px 10px;
		}
		tbody tr:nth-child(even) { background: var(--row-alt); }
		tbody td { 
			padding: 14px; 
			border-bottom: 1px solid rgba(20,27,37,0.6); 
			font-size: 13px; 
			color: #dce7f5; 
			word-wrap: break-word; 
			word-break: break-word; 
			white-space: normal; 
			vertical-align: top; 
			transition: background 0.2s ease;
		}
		.select-cell { 
			text-align: center; 
			width: 56px; 
			padding: 14px 10px;
		}
		.select-checkbox { 
			appearance: none; 
			-webkit-appearance: none; 
			width: 18px; 
			height: 18px; 
			border-radius: 6px; 
			border: 1px solid rgba(155,140,255,0.4); 
			background: rgba(12,18,25,0.6); 
			cursor: pointer; 
			display: inline-flex; 
			align-items: center; 
			justify-content: center; 
			position: relative; 
			transition: all 0.2s ease;
			box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
		}
		.select-checkbox::after { 
			content: ""; 
			width: 10px; 
			height: 10px; 
			border-radius: 3px; 
			background: linear-gradient(135deg, #9b8cff, #60d5ff); 
			opacity: 0; 
			transform: scale(0.6); 
			transition: all 0.18s ease;
			box-shadow: 0 0 10px rgba(155,140,255,0.4);
		}
		.select-checkbox:checked { 
			border-color: rgba(155,140,255,0.9); 
			background: rgba(155,140,255,0.12); 
			box-shadow: 
				inset 0 0 0 1px rgba(155,140,255,0.35), 
				0 2px 8px rgba(155,140,255,0.25);
		}
		.select-checkbox:checked::after { 
			opacity: 1; 
			transform: scale(1);
		}
		.select-checkbox:focus-visible { 
			outline: none; 
			box-shadow: 0 0 0 3px rgba(155,140,255,0.35);
		}
		tbody td:first-child { min-width: 120px; }
		tbody td:nth-child(2), tbody td:nth-child(3) { min-width: 300px; max-width: 680px; }
		tbody tr:hover { 
			background: rgba(15,24,35,0.8);
		}
		tbody tr:hover td {
			background: rgba(15,24,35,0.8);
		}

		.pagination { 
			display: flex; 
			gap: 10px; 
			align-items: center; 
			justify-content: flex-end; 
			padding: 16px; 
			border-top: 1px solid var(--border); 
			background: rgba(12,18,25,0.5);
		}
		.select { 
			background: rgba(11,17,24,0.8); 
			color: var(--text); 
			border: 1px solid var(--border); 
			padding: 10px 14px; 
			border-radius: 12px; 
			box-shadow: var(--shadow-2);
			cursor: pointer;
			transition: all 0.2s ease;
			font-size: 13px;
			font-weight: 500;
		}
		.select:hover {
			border-color: var(--border-light);
			background: rgba(12,19,27,0.9);
		}
		.select:focus {
			outline: none;
			border-color: var(--accent);
			box-shadow: 0 0 0 3px var(--focus-ring);
		}

		.toast { 
			position: fixed; 
			right: 24px; 
			bottom: 24px; 
			padding: 14px 20px; 
			border-radius: 14px; 
			background: linear-gradient(135deg, rgba(18,32,52,0.95), rgba(12,24,40,0.95)); 
			color: var(--text); 
			border: 1px solid var(--border-light); 
			box-shadow: 
				0 12px 32px rgba(0,0,0,.5),
				0 0 0 1px rgba(255,255,255,0.05) inset;
			display: none;
			backdrop-filter: blur(12px);
			z-index: 1000;
			font-weight: 500;
		}
		.toast.show { 
			display: block; 
			animation: fade 2.5s ease forwards; 
		}
		@keyframes fade { 
			0% { opacity: 0; transform: translateY(12px) scale(0.95); } 
			8% { opacity: 1; transform: translateY(0) scale(1);}
			92% { opacity: 1; transform: translateY(0) scale(1);}
			100%{ opacity:0; transform: translateY(12px) scale(0.95);} 
		}

		.skeleton { 
			background: linear-gradient(90deg, #0e1520 25%, #121b29 37%, #0e1520 63%); 
			background-size: 400% 100%; 
			animation: shimmer 1.4s infinite; 
			border-radius: 14px; 
			height: 48px; 
			margin: 16px;
		}
		@keyframes shimmer { 
			0% { background-position: 100% 0; } 
			100% { background-position: 0 0; } 
		}

		input[type="range"] { 
			appearance: none; 
			-webkit-appearance: none; 
			width: 160px; 
			height: 8px; 
			background: rgba(15,22,33,0.8); 
			border-radius: 999px; 
			border: 1px solid var(--border); 
			outline: none; 
			box-shadow: var(--shadow-2);
			transition: all 0.2s ease;
		}
		input[type="range"]:hover {
			border-color: var(--border-light);
		}
		input[type="range"]::-webkit-slider-thumb { 
			-webkit-appearance: none; 
			width: 18px; 
			height: 18px; 
			border-radius: 50%; 
			background: var(--gradient-accent);
			border: 3px solid rgba(11,17,24,0.8); 
			box-shadow: 
				0 2px 12px rgba(155,140,255,.5),
				0 0 0 2px rgba(155,140,255,0.2);
			cursor: pointer; 
			transition: all 0.2s ease; 
		}
		input[type="range"]::-webkit-slider-thumb:hover {
			transform: scale(1.15);
			box-shadow: 
				0 4px 16px rgba(155,140,255,.6),
				0 0 0 3px rgba(155,140,255,0.3);
		}
		input[type="range"]::-webkit-slider-thumb:active { transform: scale(1.05); }
		input[type="range"]::-moz-range-thumb { 
			width: 18px; 
			height: 18px; 
			border-radius: 50%; 
			background: var(--gradient-accent);
			border: 3px solid rgba(11,17,24,0.8); 
			box-shadow: 
				0 2px 12px rgba(155,140,255,.5),
				0 0 0 2px rgba(155,140,255,0.2);
			cursor: pointer;
			transition: all 0.2s ease;
		}
		input[type="range"]::-moz-range-thumb:hover {
			transform: scale(1.15);
		}

		::-webkit-scrollbar { height: 12px; width: 12px; }
		::-webkit-scrollbar-track { background: rgba(11,17,24,0.5); border-radius: 10px; }
		::-webkit-scrollbar-thumb { 
			background: linear-gradient(180deg, rgba(39,51,73,0.8), rgba(28,38,54,0.8)); 
			border: 2px solid rgba(11,17,24,0.5); 
			border-radius: 10px;
			transition: all 0.2s ease;
		}
		::-webkit-scrollbar-thumb:hover { 
			background: linear-gradient(180deg, rgba(45,58,83,0.9), rgba(32,42,61,0.9));
			border-color: rgba(155,140,255,0.3);
		}

		@media (max-width: 900px) {
			.container { padding: 24px 16px; }
			h1 { font-size: 26px; }
			.row { grid-template-columns: repeat(12, 1fr); }
			.col-4, .col-6, .col-2, .col-3, .col-8 { grid-column: span 12; }
			.header { flex-direction: column; align-items: flex-start; gap: 12px; }
			.toolbar { flex-direction: column; align-items: stretch; gap: 10px; }
			.table-wrap { margin-top: 16px; }
			.pagination { justify-content: center; }
			.card { padding: 20px; }
		}
	</style>
</head>
<body>
	<div class="container">
		<div class="header">
			<h1>Transactions Search</h1>
			<a id="btnCart" class="cart-button" href="cart.html" title="View cart">
				<span>Cart</span>
				<span class="cart-dot">•</span>
				<span id="headerCartCount" class="cart-count">0</span>
			</a>
		</div>

		<div class="card">
			<div class="row">
				<div class="col-4">
					<label class="label">PAN</label>
					<input id="pan" class="input" placeholder="e.g., AAACO8053A" aria-label="PAN number" inputmode="latin" autocomplete="on" name="pan" />
				</div>
				<div class="col-6">
					<label class="label">Name (Marathi or English)</label>
					<input id="seed" class="input" placeholder="e.g., मिताली श्रीनिवास पेंढारकर" aria-label="Person name" autocomplete="on" name="person-name" />
				</div>
				<div class="col-2" style="display:flex; align-items:flex-end; justify-content:flex-end; gap:8px;">
					<button id="btnSearch" class="btn btn-primary" title="Run search (PAN or Name)">Search</button>
					<button id="btnClear" class="btn btn-ghost" title="Clear inputs">Clear</button>
				</div>
			</div>
			<div class="toolbar" style="margin-top:8px;">
			<button id="btnPhonetics" class="btn" title="Suggest phonetic name variations"><span class="btn-label">Suggest phonetics</span><span class="spinner" aria-hidden="true"></span></button>
				<div id="chips" style="display:flex; gap:6px; flex-wrap:wrap;"></div>
			</div>
			<div class="toolbar">
				<span id="stat" class="stat">Ready</span>
				<span id="extracted" class="stat" style="display:none;"></span>
				<span id="selectedCount" class="stat">Selected 0</span>
				<div style="margin-left:auto; display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
					<label class="label" style="margin:0;">Fuzzy threshold</label>
					<input id="threshold" type="range" min="0" max="100" value="75" step="1" style="width:140px;" aria-label="Fuzzy match threshold" />
					<span id="thresholdValue" class="stat">75</span>
				</div>
				<div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
					<label class="label" style="margin:0;">Page size</label>
					<select id="pageSize" class="select">
						<option>20</option>
						<option>50</option>
						<option selected>100</option>
						<option>200</option>
					</select>
					<button id="btnSelectVisible" class="btn" title="Select all rows visible on this page">Select Page</button>
					<button id="btnSelectAll" class="btn" title="Select every row in current results">Select All</button>
					<button id="btnClearSelection" class="btn btn-ghost" title="Clear all selected rows">Clear</button>
					<button id="btnAddToCart" class="btn btn-primary" title="Move selected rows into cart" disabled>Add to Cart</button>
					<button id="btnExportPDF" class="btn" title="Export current results as PDF">Export PDF</button>
				</div>
			</div>
		</div>

		<div class="table-wrap" id="tableWrap" style="margin-top:16px;">
			<div id="loading" class="skeleton" style="display:none;"></div>
			<table id="table" style="display:none;"></table>
			<div class="pagination" id="pager" style="display:none;">
				<button class="btn btn-secondary" id="prev">Prev</button>
				<span id="pageInfo" class="stat">Page-1 / 1</span>
				<button class="btn btn-secondary" id="next">Next</button>
			</div>
		</div>
	</div>

	<div class="toast" id="toast"></div>

	<!-- PDF Generation Libraries -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
	<!-- html2canvas for Unicode text rendering -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

	<script>
	// Use localhost when opened via file://, otherwise keep same host at port 8000
	const API_BASE = (location.protocol === 'file:') ? 'http://localhost:8000' : `${location.protocol}//${location.hostname || 'localhost'}:8000`;
	const el = id => document.getElementById(id);
	const getRowKey = (row) => {
		const pan = ((row?.pan_numbers ?? row?.PAN ?? '') + '').trim();
		const doc = ((row?.DocNo ?? row?.doc_no ?? row?.docno ?? row?.DocumentNo ?? '') + '').trim();
		const buyer = ((row?.buyer ?? '') + '').trim().substring(0, 80);
		const seller = ((row?.seller ?? '') + '').trim().substring(0, 80);
		const date = ((row?.RDate ?? row?.date ?? '') + '').trim();
		return [pan, doc, buyer, seller, date].join('|');
	};
	const pruneSelection = (rows) => {
		const validKeys = new Set(rows.map(getRowKey));
		for (const key of Array.from(state.selectedKeys)) {
			if (!validKeys.has(key)) state.selectedKeys.delete(key);
		}
	};
	const CART_STORAGE_KEY = 'pansearch_cart_v1';
	const updateSelectedCount = () => {
		const badge = el('selectedCount');
		if (badge) badge.textContent = `Selected ${state.selectedKeys.size}`;
		const addBtn = el('btnAddToCart');
		if (addBtn) addBtn.disabled = state.selectedKeys.size === 0;
	};
	const updateCartCount = () => {
		const count = state.cartItems.size;
		const countEl = el('headerCartCount');
		if (countEl) countEl.textContent = String(count);
		const cartBtn = el('btnCart');
		if (cartBtn) cartBtn.title = `View cart (${count})`;
	};
	const saveCart = () => {
		try {
			const data = Array.from(state.cartItems.entries()).map(([key, row]) => ({ key, row }));
			localStorage.setItem(CART_STORAGE_KEY, JSON.stringify(data));
		} catch (err) {
			console.warn('Failed to save cart', err);
		}
	};
	const loadCart = () => {
		try {
			const raw = localStorage.getItem(CART_STORAGE_KEY);
			if (!raw) {
				state.cartItems = new Map();
				return;
			}
			const parsed = JSON.parse(raw);
			state.cartItems = new Map(parsed.map(item => [item.key, item.row]));
		} catch (err) {
			console.warn('Failed to load cart', err);
			state.cartItems = new Map();
		}
	};
	const buildRowIndex = () => {
		state.rowIndex = new Map();
		for (const row of state.allRows) {
			const key = getRowKey(row);
			state.rowIndex.set(key, row);
			if (state.cartItems.has(key)) {
				state.cartItems.set(key, row);
			}
		}
		saveCart();
	};
	let state = { allRows: [], rows: [], colsDisplay: [], colMap: {}, page: 1, pageSize: 100, threshold: 0.75, selectedKeys: new Set(), cartItems: new Map(), rowIndex: new Map() };
	loadCart();
	updateCartCount();

	function showToast(msg){ const t = el('toast'); t.textContent = msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), 2200); }
	function setStatus(msg){ el('stat').textContent = msg; }
	function setLoading(on){ el('loading').style.display = on ? 'block':'none'; el('table').style.display = on ? 'none':'table'; el('pager').style.display = on ? 'none':'flex'; }

	async function fetchPhonetics(){
		const seed = el('seed').value.trim();
		if (!seed){ showToast('Enter a name'); return; }
		const btn = el('btnPhonetics');
		btn.disabled = true; btn.classList.add('loading');
		try {
			const res = await fetch(`${API_BASE}/phonetics?` + new URLSearchParams({seed_name: seed}));
			if (!res.ok) throw new Error(await res.text());
			const json = await res.json();
			const chips = el('chips'); chips.innerHTML = '';
			const makeChip = (text) => {
				const tag = document.createElement('div');
				tag.className = 'tag';
				
				const tagText = document.createElement('span');
				tagText.className = 'tag-text';
				tagText.textContent = text;
				tagText.onclick = () => { el('seed').value = text; fetchSearch(); };
				
				const closeBtn = document.createElement('span');
				closeBtn.className = 'tag-close';
				closeBtn.textContent = '×';
				closeBtn.setAttribute('aria-label', 'Remove tag');
				closeBtn.onclick = (e) => {
					e.stopPropagation();
					tag.remove();
				};
				
				tag.appendChild(tagText);
				tag.appendChild(closeBtn);
				return tag;
			};
			const eng = Array.from(json.variations?.english || []).slice(0, 12);
			const dev = Array.from(json.variations?.marathi || []).slice(0, 12);
			for (const v of eng) chips.appendChild(makeChip(v));
			for (const v of dev) chips.appendChild(makeChip(v));
			showToast('Phonetic suggestions updated');
			
			// Automatically search with all variations
			await searchWithVariations(seed, json.variations);
		} catch(e){ console.error(e); showToast('Phonetics failed'); }
		finally { btn.disabled = false; btn.classList.remove('loading'); }
	}

	async function searchWithVariations(originalSeed, variations){
		if (!variations || (!variations.english?.size && !variations.marathi?.size)){
			// If no variations, just search with original
			await fetchSearch();
			return;
		}
		
		// Collect all variations including original
		const allVariations = new Set([originalSeed]);
		if (variations.english) {
			for (const v of variations.english) allVariations.add(v);
		}
		if (variations.marathi) {
			for (const v of variations.marathi) allVariations.add(v);
		}
		
		setStatus('Searching with variations…'); 
		setLoading(true);
		
		try {
			// Search with each variation and combine results
			const allResults = [];
			const seenKeys = new Set(); // For deduplication
			
			// Search with all variations in parallel for better performance
			const searchPromises = Array.from(allVariations)
				.filter(v => v && v.trim())
				.map(async (variation) => {
					try {
						const qs = new URLSearchParams();
						qs.set('seed_name', variation);
						qs.set('limit', '5000');
						
						const res = await fetch(`${API_BASE}/search?${qs.toString()}`);
						if (!res.ok) return [];
						
						const json = await res.json();
						return json.data || [];
					} catch(e) {
						console.warn(`Search failed for variation "${variation}":`, e);
						return [];
					}
				});
			
			// Wait for all searches to complete
			const allSearchResults = await Promise.all(searchPromises);
			
			// Combine and deduplicate results
			for (const rows of allSearchResults) {
				for (const row of rows) {
					const key = getRowKey(row);
					if (!seenKeys.has(key)) {
						seenKeys.add(key);
						allResults.push(row);
					}
				}
			}
			
			// If PAN was provided, fetch metadata
			const pan = el('pan').value.trim();
			let metaName = null, metaAge = null;
			if (pan) {
				try {
					const ext = await fetch(`${API_BASE}/pan_meta?` + new URLSearchParams({ pan }));
					if (ext.ok) {
						const ej = await ext.json().catch(()=>({}));
						metaName = (Array.isArray(ej?.names) && ej.names.length ? ej.names.join('<br><br>') : (ej.extracted_name ?? ej.name)) ?? null;
						metaAge = ej.age ?? null;
						if (typeof metaName !== 'string') metaName = metaName != null ? String(metaName) : null;
						if (typeof metaAge !== 'number') {
							const parsed = ej && (ej.age ?? ej.Age);
							const n = Number(parsed);
							metaAge = Number.isFinite(n) ? n : (parsed != null ? String(parsed) : null);
						}
						if (metaName != null || metaAge != null) {
							for (const r of allResults) { 
								r["Name"] = metaName ?? ''; 
								r["Age"] = metaAge ?? ''; 
							}
						}
						const ex = el('extracted');
						if (metaName) {
							ex.style.display = 'inline-block';
							const hasNamesList = Array.isArray(ej?.names) && ej.names.length > 0;
							const isExtracted = ej && typeof ej.extracted_name === 'string' && ej.extracted_name.length > 0;
							if (hasNamesList) {
								// Display names on separate lines
								const label = 'Names:';
								const namesHtml = ej.names.map(name => name.trim()).filter(n => n).join('<br><br>');
								ex.innerHTML = `${label}<br>${namesHtml}`;
							} else {
								ex.textContent = `${isExtracted ? 'Extracted Name' : 'Name'}: ${metaName}`;
							}
						} else {
							ex.style.display = 'none';
							ex.textContent = '';
							ex.innerHTML = '';
						}
					}
				} catch (e) {
					console.warn('Meta API error', e);
				}
			}
			
			// Update state with combined results
			state.allRows = allResults;
			buildRowIndex();
			updateCartCount();
			state.selectedKeys = new Set();
			updateSelectedCount();
			const desired = [
				{ header: 'PAN', key: 'pan_numbers' },
				{ header: 'Buyer', key: 'buyer' },
				{ header: 'Seller', key: 'seller' },
				{ header: 'Name', key: 'Name' },
				{ header: 'Age', key: 'Age' },
			];
			state.colsDisplay = desired.map(d => d.header);
			state.colMap = Object.fromEntries(desired.map(d => [d.header, d.key]));
			state.page = 1;
			applyThreshold();
			render();
			setStatus(`Found ${state.rows.length.toLocaleString()} unique rows from ${allVariations.size} variations (threshold ${Math.round(state.threshold*100)})`);
			showToast(`Found ${allResults.length} unique results`);
		} catch(e) {
			console.error(e);
			setStatus('Error');
			showToast('Search with variations failed');
		} finally { 
			setLoading(false); 
		}
	}

	async function fetchSearch(){
		const pan = el('pan').value.trim();
		const seed = el('seed').value.trim();
		if (!pan && !seed){ showToast('Enter PAN or Name'); return; }
		const qs = new URLSearchParams();
		if (pan) qs.set('pan', pan);
		if (seed) qs.set('seed_name', seed);
		qs.set('limit', '5000');
		setStatus('Searching…'); setLoading(true);
		try {
			const res = await fetch(`${API_BASE}/search?${qs.toString()}`);
			if (!res.ok) throw new Error(await res.text());
			const json = await res.json();
			state.allRows = json.data || [];
			buildRowIndex();
			updateCartCount();
			state.selectedKeys = new Set();
			updateSelectedCount();
			// If PAN provided, fetch Name/Age from external API and inject into rows
			let metaName = null, metaAge = null;
			if (pan) {
				try {
					const ext = await fetch(`${API_BASE}/pan_meta?` + new URLSearchParams({ pan }));
					if (ext.ok) {
						const ej = await ext.json().catch(()=>({}));
						// Expect normalized keys from proxy
						metaName = (Array.isArray(ej?.names) && ej.names.length ? ej.names.join('<br><br>') : (ej.extracted_name ?? ej.name)) ?? null;
						metaAge = ej.age ?? null;
						// Normalize to primitives
						if (typeof metaName !== 'string') metaName = metaName != null ? String(metaName) : null;
						let metaAgeNum = null;
						if (typeof metaAge === 'number' && Number.isFinite(metaAge)) {
							metaAgeNum = metaAge;
						} else if (metaAge != null) {
							const parsed = ej && (ej.age ?? ej.Age);
							const n = Number(parsed);
							metaAgeNum = Number.isFinite(n) ? n : null;
						}
						
						// Calculate current age based on year from first transaction
						// Formula: current_age = age_at_transaction + (current_year - transaction_year)
						let currentAge = metaAgeNum;
						if (metaAgeNum != null && state.allRows.length > 0) {
							const firstTransaction = state.allRows[0];
							// Try to get year field (case-insensitive check for robustness)
							const transactionYear = firstTransaction.year || firstTransaction.Year || firstTransaction.YEAR;
							if (transactionYear != null && transactionYear !== '') {
								const yearNum = typeof transactionYear === 'number' ? transactionYear : parseInt(String(transactionYear), 10);
								if (Number.isFinite(yearNum) && yearNum > 1900 && yearNum <= new Date().getFullYear() + 1) {
									const currentYear = new Date().getFullYear();
									currentAge = metaAgeNum + (currentYear - yearNum);
									console.log(`Age calculation: ${metaAgeNum} (age) + (${currentYear} - ${yearNum}) = ${currentAge}`);
								} else {
									console.warn('Invalid transaction year:', transactionYear);
								}
							} else {
								console.warn('Year field not found in first transaction');
							}
						}
						
						if (metaName != null || metaAgeNum != null) {
							for (const r of state.allRows) { 
								r["Name"] = metaName ?? ''; 
								r["Age"] = (metaAgeNum != null) ? currentAge : ''; 
							}
						}
							// Show name badge; label as Extracted only if extracted_name present
							const ex = el('extracted');
							if (metaName) {
								ex.style.display = 'inline-block';
								const hasNamesList = Array.isArray(ej?.names) && ej.names.length > 0;
								const isExtracted = ej && typeof ej.extracted_name === 'string' && ej.extracted_name.length > 0;
								if (hasNamesList) {
									// Display names on separate lines
									const label = 'Names:';
									const namesHtml = ej.names.map(name => name.trim()).filter(n => n).join('<br><br>');
									ex.innerHTML = `${label}<br>${namesHtml}`;
								} else {
									ex.textContent = `${isExtracted ? 'Extracted Name' : 'Name'}: ${metaName}`;
								}
							} else {
								ex.style.display = 'none';
								ex.textContent = '';
								ex.innerHTML = '';
							}
					} else {
						// Non-fatal if metadata API fails
						console.warn('Meta API failed', await ext.text());
					}
				} catch (e) {
					console.warn('Meta API error', e);
				}
			}
			// Lock table to exactly these columns in this order
			const desired = [
				{ header: 'PAN', key: 'pan_numbers' },
				{ header: 'Buyer', key: 'buyer' },
				{ header: 'Seller', key: 'seller' },
				{ header: 'Name', key: 'Name' },
				{ header: 'Age', key: 'Age' },
				{ header: 'Property Type', key: 'property_type' },
			];
			state.colsDisplay = desired.map(d => d.header);
			state.colMap = Object.fromEntries(desired.map(d => [d.header, d.key]));
			state.page = 1;
			applyThreshold();
			render();
			setStatus(`Found ${state.rows.length.toLocaleString()} rows (threshold ${Math.round(state.threshold*100)})`);
			showToast('Done');
		} catch(e){
			console.error(e);
			setStatus('Error');
			showToast('Search failed');
		} finally { setLoading(false); }
	}

	function paginate(rows, page, size){
		const start = (page-1)*size;
		return rows.slice(start, start+size);
	}

	function render(){
		const table = el('table');
		table.innerHTML = '';
		const pager = el('pager');
		if (!state.rows.length){
			table.style.display='none';
			if (pager) pager.style.display='none';
			updateSelectedCount();
			return;
		}
		const pageRows = paginate(state.rows, state.page, state.pageSize);
		table.style.display='table';
		const thead = document.createElement('thead');
		const htr = document.createElement('tr');
		const selectHeader = document.createElement('th');
		selectHeader.className = 'select-header';
		const selectAll = document.createElement('input');
		selectAll.type = 'checkbox';
		selectAll.className = 'select-checkbox';
		if (pageRows.length) {
			const checkedCount = pageRows.reduce((acc, row) => acc + (state.selectedKeys.has(getRowKey(row)) ? 1 : 0), 0);
			selectAll.checked = checkedCount === pageRows.length && checkedCount > 0;
			selectAll.indeterminate = checkedCount > 0 && checkedCount < pageRows.length;
		}
		selectAll.onchange = (e) => {
			const checked = e.target.checked;
			for (const row of pageRows) {
				const key = getRowKey(row);
				if (checked) {
					state.selectedKeys.add(key);
				} else {
					state.selectedKeys.delete(key);
				}
			}
			updateSelectedCount();
			render();
		};
		selectHeader.appendChild(selectAll);
		htr.appendChild(selectHeader);
		for (const c of state.colsDisplay){
			const th = document.createElement('th');
			th.textContent = c;
			htr.appendChild(th);
		}
		thead.appendChild(htr);
		table.appendChild(thead);
		const tbody = document.createElement('tbody');
		for (const r of pageRows){
			const tr = document.createElement('tr');
			const selectTd = document.createElement('td');
			selectTd.className = 'select-cell';
			const checkbox = document.createElement('input');
			checkbox.type = 'checkbox';
			checkbox.className = 'select-checkbox';
			const rowKey = getRowKey(r);
			checkbox.checked = state.selectedKeys.has(rowKey);
			checkbox.onchange = (event) => {
				if (event.target.checked) {
					state.selectedKeys.add(rowKey);
				} else {
					state.selectedKeys.delete(rowKey);
				}
				updateSelectedCount();
				render();
			};
			selectTd.appendChild(checkbox);
			tr.appendChild(selectTd);
			for (const c of state.colsDisplay){
				const td = document.createElement('td');
				const key = state.colMap[c];
				const v = r[key];
				if (r.name_hit_field === key && r.name_hit_snippet_html){
					td.innerHTML = String(r.name_hit_snippet_html);
				} else if (r.pan_hit_field === key && r.pan_hit_snippet_html){
					const fullText = String(v || '');
					if (fullText && r.pan_hit_snippet_html) {
						const panMatch = r.pan_hit_snippet_html.match(/<mark>([^<]+)<\/mark>/);
						if (panMatch) {
							const panToHighlight = panMatch[1];
							const regex = new RegExp(panToHighlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
							const highlighted = fullText.replace(regex, (match) => `<mark>${match}</mark>`);
							td.innerHTML = highlighted;
						} else {
							td.innerHTML = fullText;
						}
					} else {
						td.textContent = fullText;
					}
				} else {
					td.textContent = (v!==null && v!==undefined) ? String(v) : '';
				}
				tr.appendChild(td);
			}
			tbody.appendChild(tr);
		}
		table.appendChild(tbody);
		const pages = Math.max(1, Math.ceil(state.rows.length / state.pageSize));
		el('pageInfo').textContent = `Page ${state.page} / ${pages}`;
		const prevBtn = el('prev');
		const nextBtn = el('next');
		prevBtn.disabled = state.page <= 1;
		nextBtn.disabled = state.page >= pages;
		if (pager) pager.style.display = 'flex';
		updateSelectedCount();
	}

	function applyThreshold(){
		const thr = state.threshold;
		if (!Array.isArray(state.allRows)) { state.rows = []; state.selectedKeys.clear(); updateSelectedCount(); return; }
		state.rows = state.allRows.filter(r => {
			const s = typeof r.match_score === 'number' ? r.match_score : 0;
			return s >= thr;
		});
		pruneSelection(state.rows);
		state.page = 1;
		updateSelectedCount();
	}

	function exportCSV(){
		if (!state.rows.length){ showToast('No data'); return; }
		const cols = state.colsDisplay;
		const lines = [];
		lines.push(cols.map(safeCsv).join(','));
		for (const r of state.rows){ lines.push(cols.map(c=>safeCsv(r[state.colMap[c]])).join(',')); }
		const blob = new Blob([lines.join('\n')], {type:'text/csv;charset=utf-8;'});
		const url = URL.createObjectURL(blob);
		const a = document.createElement('a');
		a.href = url; a.download = 'results.csv'; a.click(); URL.revokeObjectURL(url);
		showToast('Exported CSV');
	}
	function safeCsv(v){ if (v===null||v===undefined) return ''; const s = String(v).replace(/"/g,'""'); return /[",\n]/.test(s) ? `"${s}"` : s; }

	// Helper function to ensure Unicode text is properly handled
	function prepareTextForPDF(text) {
		if (!text) return '';
		// Ensure text is a string
		let str = String(text);
		// Strip HTML
		str = str.replace(/<[^>]*>/g, '');
		// jsPDF handles UTF-8, but Devanagari needs special font
		// For now, return as-is - the font issue needs to be addressed separately
		return str;
	}

	async function exportPDF(){
		// Check if html2canvas is available
		if (typeof html2canvas === 'undefined') {
			showToast('PDF library not loaded');
			return;
		}
		
		// Check if jsPDF is available
		if (typeof window.jspdf === 'undefined') {
			showToast('PDF library not loaded');
			return;
		}
		
		// Check if table has data
		const table = el('table');
		if (!table || table.style.display === 'none' || !state.rows.length) {
			showToast('No table data to export');
			return;
		}
		
		showToast('Capturing table and generating PDF...');
		
		try {
			const { jsPDF } = window.jspdf;
			
			// Get the table wrapper element (contains table and pagination)
			const tableWrap = el('tableWrap');
			if (!tableWrap) {
				showToast('Could not find table to export');
				return;
			}
			
			// Capture only the table wrapper as canvas
			const canvas = await html2canvas(tableWrap, {
				scale: 2, // Higher quality
				useCORS: true,
				letterRendering: true,
				backgroundColor: '#0c1219', // Match the table-wrap background
				windowWidth: tableWrap.scrollWidth,
				windowHeight: tableWrap.scrollHeight,
				scrollX: 0,
				scrollY: 0,
				allowTaint: false,
				logging: false
			});
			
			// Get image dimensions
			const imgWidth = canvas.width;
			const imgHeight = canvas.height;
			
			// A4 dimensions in mm
			const pdfWidth = 210; // A4 width in mm
			const pdfHeight = 297; // A4 height in mm
			
			// Calculate scaling to fit width (maintain aspect ratio)
			// Use full width of PDF page with margins
			const margin = 5; // 5mm margin on each side
			const usableWidth = pdfWidth - (2 * margin);
			const usableHeight = pdfHeight - (2 * margin);
			
			const imgAspectRatio = imgHeight / imgWidth;
			const usableAspectRatio = usableHeight / usableWidth;
			
			let finalWidth, finalHeight;
			if (imgAspectRatio > usableAspectRatio) {
				// Image is taller - fit to height
				finalHeight = usableHeight;
				finalWidth = usableHeight / imgAspectRatio;
			} else {
				// Image is wider - fit to width
				finalWidth = usableWidth;
				finalHeight = usableWidth * imgAspectRatio;
			}
			
			// Create PDF
			const doc = new jsPDF('p', 'mm', 'a4');
			
			// Calculate how many pages we need
			const pagesNeeded = Math.ceil(finalHeight / usableHeight);
			
			// Add image across multiple pages if needed
			for (let page = 0; page < pagesNeeded; page++) {
				if (page > 0) {
					doc.addPage();
				}
				
				// Calculate the portion of image for this page
				const sourceY = (page * usableHeight / finalHeight) * imgHeight;
				const remainingHeight = imgHeight - sourceY;
				const sourceHeight = Math.min(usableHeight / finalHeight * imgHeight, remainingHeight);
				
				// Calculate destination dimensions for this page
				const destHeight = Math.min(usableHeight, finalHeight - (page * usableHeight));
				
				// Center the image horizontally
				const destX = margin + (usableWidth - finalWidth) / 2;
				const destY = margin;
				
				// Create a temporary canvas for this page's portion
				const pageCanvas = document.createElement('canvas');
				pageCanvas.width = imgWidth;
				pageCanvas.height = sourceHeight;
				const ctx = pageCanvas.getContext('2d');
				
				// Draw the portion of the original canvas
				ctx.drawImage(canvas, 0, sourceY, imgWidth, sourceHeight, 0, 0, imgWidth, sourceHeight);
				
				// Convert to image
				const pageImgData = pageCanvas.toDataURL('image/png', 1.0);
				
				// Add to PDF
				doc.addImage(pageImgData, 'PNG', destX, destY, finalWidth, destHeight);
			}
			
			// Save the PDF
			const fileName = `transaction_table_${new Date().toISOString().split('T')[0]}.pdf`;
			doc.save(fileName);
			showToast('Table PDF exported successfully');
		} catch(e) {
			console.error('PDF export error:', e);
			showToast('PDF export failed: ' + (e.message || 'Unknown error'));
		}
	}
	
	// Old client-side PDF generation (kept for reference, but not used)
	function exportPDF_old(){
		if (!state.rows.length){ showToast('No data'); return; }
		if (typeof window.jspdf === 'undefined') {
			showToast('PDF library not loaded');
			return;
		}
		
		const { jsPDF } = window.jspdf;
		const doc = new jsPDF('p', 'mm', 'a4'); // Portrait orientation to match sample
		
		// Note: jsPDF has limited Unicode support by default
		// Devanagari (Marathi) text may not render correctly without a custom font
		// The text will be included but may appear as garbled characters
		// To fix this properly, we would need to add a Unicode font like Noto Sans Devanagari
		const pageWidth = doc.internal.pageSize.getWidth();
		const pageHeight = doc.internal.pageSize.getHeight();
		const margin = 15;
		const contentWidth = pageWidth - (2 * margin);
		
		// Helper function to add REAL VALUE header (first page only)
		function addRealValueHeader(doc) {
			// REAL VALUE logo and text in top right
			doc.setFontSize(14);
			doc.setFont(undefined, 'bold');
			doc.setTextColor(33, 150, 243); // Blue color
			doc.text('REAL VALUE', pageWidth - margin, margin + 5, { align: 'right' });
			
			doc.setFontSize(8);
			doc.setFont(undefined, 'normal');
			doc.setTextColor(100, 150, 200); // Lighter blue
			doc.text('REAL INSIGHTS DELIVERED', pageWidth - margin, margin + 10, { align: 'right' });
		}
		
		// Helper function to add header for other pages
		function addHeader(doc, pageNum) {
			doc.setFontSize(16);
			doc.setFont(undefined, 'bold');
			doc.setTextColor(40, 40, 40);
			doc.text('Transaction Search Report', margin, margin + 8);
			
			doc.setFontSize(10);
			doc.setFont(undefined, 'normal');
			doc.setTextColor(100, 100, 100);
			const dateStr = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
			doc.text(`Generated on: ${dateStr}`, pageWidth - margin, margin + 8, { align: 'right' });
			
			// Header line
			doc.setDrawColor(200, 200, 200);
			doc.setLineWidth(0.5);
			doc.line(margin, margin + 12, pageWidth - margin, margin + 12);
		}
		
		// Helper function to add footer (first page style)
		function addRealValueFooter(doc) {
			const footerY = pageHeight - 25;
			
			// Colored gradient line (blue, orange, red)
			doc.setDrawColor(33, 150, 243); // Blue
			doc.setLineWidth(2);
			doc.line(margin, footerY, pageWidth - margin, footerY);
			
			// Address on left
			doc.setFontSize(8);
			doc.setFont(undefined, 'normal');
			doc.setTextColor(60, 60, 60);
			doc.text('B1-001, U/B Floor, Boomerang Chandivali Farm Road, Powai, Andheri East, Mumbai, Maharashtra 400072', 
				margin, footerY + 5);
			
			// Contact info on right
			doc.setTextColor(33, 150, 243); // Blue for links
			doc.text('www.real-value.co.in', pageWidth - margin, footerY + 5, { align: 'right' });
			doc.text('info@real-value.co.in', pageWidth - margin, footerY + 9, { align: 'right' });
			doc.text('+91 88284 05969', pageWidth - margin, footerY + 13, { align: 'right' });
		}
		
		// Helper function to add footer for other pages
		function addFooter(doc, pageNum, totalPages) {
			const footerY = pageHeight - margin;
			doc.setFontSize(9);
			doc.setFont(undefined, 'normal');
			doc.setTextColor(120, 120, 120);
			
			// Footer line
			doc.setDrawColor(200, 200, 200);
			doc.setLineWidth(0.5);
			doc.line(margin, footerY - 8, pageWidth - margin, footerY - 8);
			
			// Page number
			doc.text(`Page ${pageNum} of ${totalPages}`, pageWidth / 2, footerY, { align: 'center' });
			
			// Confidential watermark text in footer
			doc.setFontSize(8);
			doc.setTextColor(180, 180, 180);
			doc.text('CONFIDENTIAL', pageWidth - margin, footerY, { align: 'right' });
		}
		
		// Helper function to add watermark
		function addWatermark(doc) {
			// Use very light gray color for watermark effect
			doc.setFontSize(72);
			doc.setFont(undefined, 'bold');
			doc.setTextColor(230, 230, 230); // Very light gray for subtle watermark
			doc.text('CONFIDENTIAL', pageWidth / 2, pageHeight / 2, { 
				align: 'center',
				angle: 45
			});
		}
		
		// Get all unique columns from all rows
		function getAllColumns(rows) {
			const allCols = new Set();
			rows.forEach(row => {
				Object.keys(row).forEach(key => {
					// Exclude internal fields
					if (!['pan_upper', 'pan_raw', 'match_score', 'name_hit_field', 'name_hit_snippet', 'name_hit_snippet_html', 'pan_hit_field', 'pan_hit_snippet_html'].includes(key)) {
						allCols.add(key);
					}
				});
			});
			return Array.from(allCols).sort();
		}
		
		let pageNum = 1;
		const allColumns = getAllColumns(state.rows);
		
		// PAGE 1: Summary table matching sample PDF structure
		addRealValueHeader(doc);
		addWatermark(doc);
		
		// Main title - centered
		doc.setFontSize(14);
		doc.setFont(undefined, 'bold');
		doc.setTextColor(40, 40, 40);
		doc.text('Property Summary Report for Financial Creditor', pageWidth / 2, margin + 30, { align: 'center' });
		
		// Get entity name from first transaction if available, or use PAN
		const firstRow = state.rows[0];
		const entityName = firstRow?.name_extracted || firstRow?.Name || firstRow?.pan_numbers || 'N/A';
		doc.setFontSize(12);
		doc.setFont(undefined, 'bold');
		doc.setTextColor(60, 60, 60);
		doc.text(entityName.toUpperCase(), pageWidth / 2, margin + 38, { align: 'center' });
		
		// "To:" section (optional - can be customized)
		const toY = margin + 50;
		doc.setFontSize(9);
		doc.setFont(undefined, 'normal');
		doc.setTextColor(80, 80, 80);
		doc.text('To,', margin, toY);
		doc.text('The DGM,', margin + 5, toY + 5);
		doc.text('legal & recovery department,', margin + 5, toY + 10);
		doc.text('Abhyudaya co op bank ltd.,', margin + 5, toY + 15);
		doc.text('parel', margin + 5, toY + 20);
		doc.text('MOB NO. 8591948712/8169452713', margin + 5, toY + 25);
		
		// Table title
		const tableTitleY = toY + 35;
		doc.setFontSize(10);
		doc.setFont(undefined, 'bold');
		doc.setTextColor(40, 40, 40);
		doc.text('1) Details : Transaction Summary', margin, tableTitleY);
		
		// Prepare summary table data with serial numbers
		const summaryHeaders = ['Sr', ...state.colsDisplay];
		const summaryData = state.rows.map((row, idx) => {
			const rowData = [idx + 1]; // Serial number
			state.colsDisplay.forEach(header => {
				const key = state.colMap[header];
				const val = row[key];
				// Prepare text for PDF - handle Unicode properly
				const displayVal = prepareTextForPDF(val);
				rowData.push(displayVal);
			});
			return rowData;
		});
		
		// Create HTML table for proper Unicode rendering
		// jsPDF doesn't support Devanagari, so we'll render as image using html2canvas
		const tempDiv = document.createElement('div');
		tempDiv.style.position = 'absolute';
		tempDiv.style.left = '-9999px';
		tempDiv.style.width = (pageWidth - 2 * margin) + 'mm';
		tempDiv.style.fontFamily = 'Arial, sans-serif';
		tempDiv.style.fontSize = '8px';
		document.body.appendChild(tempDiv);
		
		// Create table HTML
		let tableHTML = `
			<table style="width: 100%; border-collapse: collapse; font-size: 8px; font-family: Arial, sans-serif;">
				<thead>
					<tr style="background-color: rgb(227, 242, 253);">
		`;
		summaryHeaders.forEach(header => {
			tableHTML += `<th style="padding: 3px; border: 1px solid rgb(200, 200, 200); text-align: left; font-weight: bold; color: rgb(40, 40, 40);">${header}</th>`;
		});
		tableHTML += `</tr></thead><tbody>`;
		
		summaryData.forEach((row, idx) => {
			const bgColor = idx % 2 === 0 ? 'rgb(255, 255, 255)' : 'rgb(250, 250, 250)';
			tableHTML += `<tr style="background-color: ${bgColor};">`;
			row.forEach((cell, cellIdx) => {
				const align = cellIdx === 0 ? 'center' : (cellIdx === row.length - 1 ? 'right' : 'left');
				// Escape HTML but preserve Unicode
				const cellText = String(cell || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
				tableHTML += `<td style="padding: 2px; border: 1px solid rgb(200, 200, 200); text-align: ${align}; color: rgb(60, 60, 60); word-wrap: break-word;">${cellText}</td>`;
			});
			tableHTML += `</tr>`;
		});
		tableHTML += `</tbody></table>`;
		
		tempDiv.innerHTML = tableHTML;
		
		// Render table as image using html2canvas
		if (typeof html2canvas !== 'undefined') {
			showToast('Rendering table with Unicode support...');
			html2canvas(tempDiv, {
				scale: 2,
				useCORS: true,
				letterRendering: true,
				backgroundColor: '#ffffff'
			}).then(canvas => {
				const imgData = canvas.toDataURL('image/png');
				const imgWidth = pageWidth - 2 * margin;
				const imgHeight = (canvas.height * imgWidth) / canvas.width;
				
				// Add image to PDF
				doc.addImage(imgData, 'PNG', margin, tableTitleY + 5, imgWidth, imgHeight);
				
				// Clean up
				document.body.removeChild(tempDiv);
				
				// Continue with rest of PDF generation
				continuePDFGeneration();
			}).catch(err => {
				console.error('html2canvas error:', err);
				document.body.removeChild(tempDiv);
				// Fallback to autoTable if html2canvas fails
				fallbackToAutoTable();
			});
		} else {
			// Fallback if html2canvas not available
			document.body.removeChild(tempDiv);
			fallbackToAutoTable();
		}
		
		function fallbackToAutoTable() {
			const lightBlue = [227, 242, 253];
			doc.autoTable({
				startY: tableTitleY + 5,
				head: [summaryHeaders],
				body: summaryData,
				theme: 'striped',
				headStyles: { 
					fillColor: lightBlue,
					textColor: [40, 40, 40],
					fontStyle: 'bold',
					fontSize: 9
				},
				bodyStyles: { 
					fontSize: 8,
					textColor: [60, 60, 60],
					cellPadding: 2
				},
				alternateRowStyles: { 
					fillColor: [250, 250, 250]
				},
				margin: { left: margin, right: margin },
				styles: { 
					cellPadding: 2,
					overflow: 'linebreak',
					cellWidth: 'wrap',
					lineWidth: 0.1,
					lineColor: [200, 200, 200]
				},
				columnStyles: {
					0: { cellWidth: 12, halign: 'center' },
					1: { cellWidth: 28, halign: 'left' },
					2: { cellWidth: 45, halign: 'left' },
					3: { cellWidth: 45, halign: 'left' },
					4: { cellWidth: 35, halign: 'left' },
					5: { cellWidth: 15, halign: 'right' }
				}
			});
			continuePDFGeneration();
		}
		
		function continuePDFGeneration() {
			// Add footer for first page
			addRealValueFooter(doc);
			
			// PAGES 2+: Detailed view for each transaction with all columns
			// Start first detailed transaction on a new page (page 2)
			doc.addPage();
			let pageNum = 2;
			
			state.rows.forEach((row, index) => {
				// For transactions after the first, start on a new page
				if (index > 0) {
					// Check if previous table overflowed
					if (doc.lastAutoTable && doc.lastAutoTable.finalY > pageHeight - 40) {
						// Already on new page from overflow
						pageNum = doc.internal.getCurrentPageInfo().pageNumber;
					} else {
						doc.addPage();
						pageNum = doc.internal.getCurrentPageInfo().pageNumber;
					}
					addHeader(doc, pageNum);
					addWatermark(doc);
				} else {
					// First detailed transaction - add header
					addHeader(doc, pageNum);
					addWatermark(doc);
				}
				
				doc.setFontSize(11);
				doc.setFont(undefined, 'bold');
				doc.setTextColor(40, 40, 40);
				doc.text(`Transaction ${index + 1} of ${state.rows.length}`, margin, margin + 25);
				
				// Prepare detailed data - all columns
				const detailData = [];
				allColumns.forEach(col => {
					const val = row[col];
					let displayVal = '';
					if (val !== null && val !== undefined) {
						displayVal = String(val);
						// Strip HTML tags
						displayVal = displayVal.replace(/<[^>]*>/g, '');
						// Limit very long values
						if (displayVal.length > 200) {
							displayVal = displayVal.substring(0, 200) + '...';
						}
					}
					detailData.push([
						{ content: col, styles: { fontStyle: 'bold', fillColor: [240, 240, 240] } },
						{ content: displayVal, styles: { fontStyle: 'normal' } }
					]);
				});
				
				const startY = margin + 30;
				
				doc.autoTable({
					startY: startY,
					head: [['Field', 'Value']],
					body: detailData,
					theme: 'striped',
					headStyles: { 
						fillColor: [60, 60, 60],
						textColor: [255, 255, 255],
						fontStyle: 'bold',
						fontSize: 9
					},
					bodyStyles: { 
						fontSize: 8,
						textColor: [40, 40, 40]
					},
					alternateRowStyles: { 
						fillColor: [250, 250, 250]
					},
					margin: { left: margin, right: margin },
					styles: { 
						cellPadding: 3,
						overflow: 'linebreak',
						cellWidth: 'wrap'
					},
					columnStyles: {
						0: { cellWidth: 60, fontStyle: 'bold' },
						1: { cellWidth: contentWidth - 60 }
					}
				});
			});
			
			// Update page numbers in all footers
			const totalPages = doc.internal.pages.length - 1;
			for (let i = 1; i <= totalPages; i++) {
				doc.setPage(i);
				if (i === 1) {
					// First page uses Real Value footer
					addRealValueFooter(doc);
				} else {
					addFooter(doc, i, totalPages);
					addHeader(doc, i);
					addWatermark(doc);
				}
			}
			
			// Save the PDF
			const fileName = `transaction_report_${new Date().toISOString().split('T')[0]}.pdf`;
			doc.save(fileName);
			showToast('PDF exported successfully');
		}
	}

	el('btnSearch').onclick = fetchSearch;
	el('btnPhonetics').onclick = fetchPhonetics;
	el('btnClear').onclick = () => { el('pan').value=''; el('seed').value=''; setStatus('Ready'); state.selectedKeys.clear(); updateSelectedCount(); render(); };
el('btnSelectVisible').onclick = () => {
		const pageRows = paginate(state.rows, state.page, state.pageSize);
		for (const row of pageRows) {
			state.selectedKeys.add(getRowKey(row));
		}
		updateSelectedCount();
		render();
	};
	el('btnSelectAll').onclick = () => {
		for (const row of state.rows) {
			state.selectedKeys.add(getRowKey(row));
		}
		updateSelectedCount();
		render();
	};
	el('btnClearSelection').onclick = () => {
		state.selectedKeys.clear();
		updateSelectedCount();
		render();
	};
const addToCartBtn = el('btnAddToCart');
if (addToCartBtn) {
	addToCartBtn.onclick = () => {
		if (!state.selectedKeys.size) {
			showToast('Select at least one row first');
			return;
		}
		let added = 0;
		for (const key of state.selectedKeys) {
			const row = state.rowIndex.get(key);
			if (!row) continue;
			if (!state.cartItems.has(key)) {
				state.cartItems.set(key, row);
				added += 1;
			}
		}
		if (added === 0) {
			showToast('Selected rows are already in the cart');
		} else {
			saveCart();
			updateCartCount();
			showToast(`Added ${added} item${added === 1 ? '' : 's'} to cart`);
		}
	};
}
	el('btnExport').onclick = exportCSV;
	el('btnExportPDF').onclick = exportPDF;
	el('prev').onclick = ()=>{ if (state.page>1){ state.page--; render(); }};
	el('next').onclick = ()=>{ const pages = Math.max(1, Math.ceil(state.rows.length / state.pageSize)); if (state.page<pages){ state.page++; render(); }};
	el('pageSize').onchange = (e)=>{ state.pageSize = parseInt(e.target.value, 10) || 100; state.page = 1; render(); };
	const thresholdEl = el('threshold');
	const thresholdValue = el('thresholdValue');
	// Initialize button ripple effects once handlers exist in DOM
	initButtonRipples();
	thresholdEl.oninput = (e)=>{
		const v = parseInt(e.target.value, 10);
		thresholdValue.textContent = String(v);
		state.threshold = isFinite(v) ? (v/100) : 0.75;
		applyThreshold();
		render();
	};
updateSelectedCount();
updateCartCount();
	</script>
</body>
</html>
